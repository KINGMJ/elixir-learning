# 10. alias, require 和 import

为了方便软件重用，Elixir提供了三个指令`alias`、`require`和`import`，以及`use`宏。

## alias

代码见`demo5.ex`

`alias`可以让我们通过别名去访问模块

```
defmodule Sayings.Greetings do
  def basic(name), do: "Hi, #{name}"
end

defmodule Example do
  alias Sayings.Greetings

  def greeting(name), do: Greetings.basic(name)
end

# Without alias

defmodule Example do
  def greeting(name), do: Sayings.Greetings.basic(name)
end
```

如果别名有冲突，或者我们想给模块命一个不同的名字时，可以使用`:as`参数

```
defmodule Example do
  alias Sayings.Greetings, as: Hi

  def print_message(name), do: Hi.basic(name)
end
```

也可以指定多个别名：

```
defmodule Example do
  alias Sayings.{Greetings, Farewells}
end
```

## import

代码见`demo6.ex`

每当我们想访问其他模块中的函数或宏而不使用完全限定的名称时，我们都会使用`import`

请注意，我们只能导入公共函数，因为从外部无法访问私有函数。

```
iex> import List, only: [duplicate: 2]
List
iex> duplicate :ok, 3
[:ok, :ok, :ok]
```

默认情况下，`import`会导入模块中的所有函数和宏，我们可以通过`:only`（只导入该函数）和`:except`（除了该函数）来进行过滤

## require

`require`调用其他模块的宏，与`import`的区别是`require`对宏有效而对函数无效

```
defmodule Example do
  require SuperMacros

  SuperMacros.do_stuff
end
```

`alias`、`require`和`import`都支持词法范围。对于下面的代码，`Math.List`只作用于`plus`

```
defmodule Math do
  def plus(a, b) do
    alias Math.List
    # ...
  end

  def minus(a, b) do
    # ...
  end
end
```

## use

`use`宏经常用作扩展点。允许另一个模块在当前模块注入任何代码。

```
defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end

```

对于alias/import/require/use，都支持对多个模块的导入

```
alias MyApp.{Foo, Bar, Baz}
```

