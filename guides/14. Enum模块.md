# 14. Enum 模块

> 官网：https://hexdocs.pm/elixir/Enum.html#content

## all?(enumerable, fun \\ fn x -> x end)

可枚举中`fun.(element)`所有项都返回`true`时，`all?`返回`true`

```
iex> Enum.all?([2, 4, 6], fn x -> rem(x, 2) == 0 end)
true

iex> Enum.all?([2, 3, 4], fn x -> rem(x, 2) == 0 end)
false
```

## each(enumerable, fun)

有时候需要遍历某个集合进行操作，但是不想产生新的值（不把函数的遍历调用结果返回），这种情况下，可以使用 each：

```
iex> Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
one
two
three
:ok
```

## map(enumerable, fun)

如果需要把执行结果做为一个新集合返回的话，可以使用`map`函数：

```
iex> Enum.map([1, 2, 3], fn x -> x * 2 end)
[2, 4, 6]

iex> Enum.map([a: 1, b: 2], fn {k, v} -> {k, -v} end)
[a: -1, b: -2]
```

## reduce(enumerable, fun)

`reduce(enumerable, acc, fun)`

使用 `reduce`，我们可以把集合不断计算，最终得到一个值。我们可以提供一个可选的累加值，如果没有累加值，集合中的第一个值会被使用。

```
iex> Enum.reduce([1, 2, 3, 4], fn x, acc -> x * acc end)
24

iex> Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)
6
```

## into(enumerable, collectable)

把给定的`enumerable`插入到给定的`collectable`里

```
iex> Enum.into([1, 2], [])
[1, 2]

iex> Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}

iex> Enum.into(%{a: 1}, %{b: 2})
%{a: 1, b: 2}

iex> Enum.into([a: 1, a: 2], %{})
%{a: 2}
```

`into(enumerable, collectable, transform)`

把给定的`enumerable`经过函数转换插入到给定的`collectable`里

```
# 2,3 乘以 3 后，插入到[3] 里
iex> Enum.into([2, 3], [3], fn x -> x * 3 end)
[3, 6, 9]

iex> Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -> {k, v * 2} end)
%{a: 2, b: 4, c: 3}
```

## zip(enumerables)

把有限的可枚举集合压缩成元组列表

```
iex> Enum.zip([[:a,:b,:c],[1, 2, 3]]) 
[a: 1, b: 2, c: 3]

iex> Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])
[{1, :a}, {2, :b}, {3, :c}]
```

`zip(enumerable1, enumerable2)`

把两个可枚举集合压缩成元组列表

```
iex> Enum.zip([1, 2, 3], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]

iex> Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]
```

## join(enumerable, joiner \\ "")

把给定的可枚举转换为二进制，用`joiner`隔开

```
iex> Enum.join([1, 2, 3])
"123"

iex> Enum.join([1, 2, 3], " = ")
"1 = 2 = 3"
```

## count(enumerable)

返回可枚举元素的数量

```
iex> Enum.count([1, 2, 3])
3
```

`count(enumerable, fun)`

返回可枚举满足`fun`的元素数量

```
iex> Enum.count([1, 2, 3, 4, 5], fn x -> rem(x, 2) == 0 end)
2
```
