# case, cond 和 if

## case

代码见`demo1.ex`

`case` 允许我们将一个值与许多模式进行匹配，直到找到匹配的值

子句允许通过guards指定额外的条件

guards的错误不会泄露，而只是让guards失败

如果没有任何项匹配，则会报错


## cond

代码见`demo2.ex`

它与`case`的区别就是，`cond`检查不同的条件，直到找到第一个不是`nil`或`false`的条件

如果所有的条件都返回`nil`或`false`，则会引发错误。出于这个原因，有必要添加一个最终的条件，等于`true`，这样总是能匹配到。

注意`cond`认为除`nil`和`false`外的其他任何值都为true


## if 和 unless

如果只需要检查一个条件，用`if`或`unless`即可。

```
iex> if true do
...>   "This works!"
...> end
"This works!"
iex> unless true do
...>   "This will never be seen"
...> end
nil
```
如果`if`的条件返回`false`或`nil`，则`do/end`之间的函数部分不会被执行，而是返回一个`nil`。`unless`刚好相反。

它们同样都支持`else`代码块：

```
iex> if nil do
...>   "This won't be seen"
...> else
...>   "This will"
...> end
"This will"
```

## do/end

```
iex> if true, do: 1 + 2
3
```

这个例子中，`true`和`do:`中间有个逗号，这是因为使用了Elixir的常规语法，每个参数都用逗号隔开。我们称这种语法使用了关键字列表。我们也可以使用关键字传递`else`。

```
iex> if false, do: :this, else: :that
:that
```

## with

https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1

用于组合匹配子句，可以用来代替`case`嵌套语句

见`demo9.ex`

```
defmodule Demo9 do
  def fun do
    data = %{width: 10, height: 5}
    
    with {:ok, width} <- Map.fetch(data, :width),
         {:ok, height} <- Map.fetch(data, :height) do
      {:ok, width * height}
    end
  end
end

iex> Demo9.fun    
{:ok, 50} 
```

如果所有的子句都匹配成功，则执行`do`里面的语句；否则，链终止，并返回不匹配的值

```
defmodule Demo9 do
  def fun2 do
    data = %{ height: 5}

    with {:ok, width} <- Map.fetch(data, :width),
         {:ok, height} <- Map.fetch(data, :height) do
      {:ok, width * height}
    end
  end
end

iex> Demo9.fun2    
:error
```

哨兵子句也可以用于该模式中

```
 def fun3 do
   data = %{width: 10, height: 5}

    with {:ok, width} <- Map.fetch(data, :width),
         {:ok, height} when height<5 <- Map.fetch(data, :height) do
      {:ok, width * height}
    end
  end

iex> Demo9.fun3   
{:ok, 5}
```

它会匹配`Map.fetch(data, :height)`并得到匹配结果，但不会执行`do`里面的语句


还可以使用`with do else end`的语句，如果`else`块没有匹配子句，则会引发`WithClauseError`异常