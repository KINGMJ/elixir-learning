# 13. 并发

Elixir是面向并发的编程语言，基于Erlang VM(BEAM)虚拟机。Elixir能够非常简单地实现并发编程，它的并发模型是 actor 模型。


## 进程（Processes）

创建一个新进程最简单的办法是使用`spawn/1`，它接受一个匿名函数或命名函数作为参数

`spawn/1`返回一个PID（进程标识符）。生成的进程将执行给定的函数，并在函数完成后退出

```
iex> pid = spawn fn -> 1 + 2 end
#PID<0.44.0>
iex> Process.alive?(pid)
false
```

通过`self/0`命令检索当前进程的PID

```
iex> self()
#PID<0.41.0>
iex> Process.alive?(self())
true
```

异步运行函数，可以用`spawn/3`

```
defmodule Example do
  def add(a, b) do
    IO.puts(a + b)
  end
end

iex> spawn(Example, :add, [2, 3])
5
#PID<0.80.0>
```

### 消息传递

我们可以通过`send/2`发送信息到进程，通过`receive/1`接收。

```
iex> send self(), {:hello, "world"}
{:hello, "world"}
iex> receive do
...>   {:hello, msg} -> msg
...>   {:world, msg} -> "won't match"
...> end
"world"
```

`receive/1`支持哨兵子句和`case/2`等子句。

`receive/1`支持超时时间

```
iex> receive do
...>   {:hello, msg}  -> msg
...> after
...>   1_000 -> "nothing after 1s"
...> end
"nothing after 1s"
```

### 进程链接

`spwan_link/1`


`spawn/1`和`spawn_link/1`是用于在Elixir中创建进程的基本原型。尽管到目前为止我们已经完全使用它们，但大部分时间我们都会使用基于它们的抽象。让我们看看最常见的一个，称为任务。

### 任务

使用`Task.start/1`和`Task.start_link/1`来替代`spawn/1`和`spawn_link/1`。它们会返回`{:ok,pid}`，而不仅仅是PID。此外，`Task`提供了方便的功能，如`Task.async/1`和`Task.await/1`
